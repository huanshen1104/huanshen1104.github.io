<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL中的锁机制</title>
    <url>/2018/12/01/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制</strong>。在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。本章我们着重讨论MySQL锁机制 的特点，常见的锁问题，以及解决MySQL锁问题的一些方法或建议。<br> <br>Mysql用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。这些锁统称为悲观锁(Pessimistic Lock)。</p>
<h1 id="MySQL锁概述"><a href="#MySQL锁概述" class="headerlink" title="MySQL锁概述"></a>MySQL锁概述</h1><p>相对其他数据库而言，MySQL的锁机制比较简单，其最 显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 <br><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 <br><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 <br><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 <br>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<h1 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h1><p><strong>MySQL的表级锁有两种模式</strong>：<strong>表共享读锁（Table Read Lock）</strong> 和 <strong>表排它写锁（Table Write Lock）</strong>。 <br>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！根据下图所示的例子可以知道，当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待，直到锁被释放为止。</p>
<p><strong>MyISAM存储引擎的写锁阻塞读例子</strong>： <br>当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。   </p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031556988.png"></p>
<p><strong>MyISAM存储引擎的读锁阻塞写例子:</strong> <br>一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。 <br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031557619.png"></p>
<h2 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h2><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。在示例中，显式加锁基本上都是为了演示而已，并非必须如此。   </p>
<p>给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如， 有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select sum(total) from orders;</span><br><span class="line">Select sum(subtotal) from order_detail;</span><br></pre></td></tr></table></figure>

<p>这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock tables orders read local, order_detail read local;</span><br><span class="line">Select sum(total) from orders;</span><br><span class="line">Select sum(subtotal) from order_detail;</span><br><span class="line">Unlock tables;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要特别说明以下两点内容：   </p>
<ul>
<li>上面的例子在LOCK TABLES时加了<strong>“local”</strong>选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面还会进一步介绍。   </li>
<li>在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的 情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。</li>
</ul>
</blockquote>
<p>当使用LOCK TABLES时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁定多少次，否则也会出错！举例说明如下：<br>(1) 对actor表获得读锁：</p>
<blockquote>
<p>mysql&gt; lock table actor read; <br>Query OK, 0 rows affected (0.00 sec)</p>
</blockquote>
<p>(2) 但是通过别名访问会提示错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select a.first_name,a.last_name,b.first_name,b.last_name </span><br><span class="line">from actor a,actor b </span><br><span class="line">where a.first_name = b.first_name and a.first_name = &#x27;Lisa&#x27; and a.last_name = &#x27;Tom&#x27; </span><br><span class="line">and a.last_name &lt;&gt; b.last_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ERROR 1100 (HY000): Table ‘a’ was not locked with LOCK TABLES</p>
</blockquote>
<p>(3) 需要对别名分别锁定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; lock table actor as a read,actor as b read;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Query OK, 0 rows affected (0.00 sec)</p>
</blockquote>
<p>(4) 按照别名的查询可以正确执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select a.first_name,a.last_name,b.first_name,b.last_name </span><br><span class="line">from actor a,actor b where a.first_name = b.first_name </span><br><span class="line">and a.first_name = &#x27;Lisa&#x27; and a.last_name = &#x27;Tom&#x27; </span><br><span class="line">and a.last_name &lt;&gt; b.last_name;</span><br></pre></td></tr></table></figure>

<h2 id="查询表级锁争用情况"><a href="#查询表级锁争用情况" class="headerlink" title="查询表级锁争用情况"></a>查询表级锁争用情况</h2><p>可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;table%&#x27;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Variable_name | Value</strong> <br><em>Table_locks_immediate | 2979</em> <br><em>Table_locks_waited | 0</em> <br>2 rows in set (0.00 sec))</p>
</blockquote>
<p>如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。</p>
<h2 id="并发插入（Concurrent-Inserts）"><a href="#并发插入（Concurrent-Inserts）" class="headerlink" title="并发插入（Concurrent Inserts）"></a>并发插入（Concurrent Inserts）</h2><p>上文提到过MyISAM表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM表也支持查询和插入操作的并发进行。 <br>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。</p>
<ul>
<li>当concurrent_insert设置为0时，不允许并发插入。</li>
<li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。</li>
<li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li>
</ul>
<p>在下面的例子中，session_1获得了一个表的READ LOCAL锁，该线程可以对表进行查询操作，但不能对表进行更新操作；其他的线程（session_2），虽然不能对表进行删除和更新操作，但却可以对该表进行并发插入操作，这里假设该表中间不存在空洞。</p>
<p><strong>MyISAM存储引擎的读写（INSERT）并发例子：</strong> <br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031558874.png"><br>可以利用MyISAM存储引擎的并发插入特性，来解决应 用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行 OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。</p>
<h2 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h2><p>前面讲过，MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？<strong>答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要</strong>。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM的调度行为。</p>
<ul>
<li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li>
<li>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。</li>
<li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li>
</ul>
<p>虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。 <br>另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p>
<p>上面已经讨论了写优先调度机制带来的问题和解决办法。这 里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语 句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每 一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。</p>
<h1 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h1><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>
<p><strong>1、事务（Transaction）及其ACID属性</strong> <br>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
<ul>
<li>  原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>  一致性（Consistency）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li>  隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>  持久性（Durability）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<p><strong>2、并发事务带来的问题</strong> <br>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p>
<ul>
<li>  更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</li>
<li>  脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li>
<li>  不可重复读（Non-Repeatable Reads）：一个事务在读取的某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li>
<li>  幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li>
</ul>
<p><strong>3、事务隔离级别</strong> <br>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
<p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</p>
<ul>
<li>  一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>  另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</li>
</ul>
<p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。 <br>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p>
<ul>
<li><p>  快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where ?; </span><br></pre></td></tr></table></figure></li>
<li><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。 <br>  下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert into table values (…);</span><br><span class="line">update table set ? where ?;</span><br><span class="line">delete from table where ?;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。下表很好地概括了这4个隔离级别的特性。 <br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031602347.png"></p>
<h2 id="获取InonoD行锁争用情况"><a href="#获取InonoD行锁争用情况" class="headerlink" title="获取InonoD行锁争用情况"></a>获取InonoD行锁争用情况</h2><p>可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031608290.png"></p>
<p>如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>
<h2 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h2><p>InnoDB实现了以下两种类型的行锁。</p>
<ul>
<li>  <strong>共享锁（s）：又称读锁。</strong>允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
<li>  <strong>排他锁（Ｘ）：又称写锁。</strong>允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。</li>
<li>  对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据。 <br>  对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句：<strong>update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型</strong>，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。<strong>所以加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</strong></li>
</ul>
<p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的<strong>意向锁（Intention Locks）</strong>，这两种意向锁都是表锁。</p>
<ul>
<li>  意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>  意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ul>
<p><strong>InnoDB行锁模式兼容性列表:</strong> <br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031608571.png"></p>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。 <br>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。 <br>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>
<ul>
<li>  共享锁（S）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code>。</li>
<li>  排他锁（X）：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code>。</li>
</ul>
<p>用<code>SELECT ... IN SHARE MODE</code>获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。<strong>但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</strong></p>
<h2 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h2><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着： <strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong> <br>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。</p>
<p>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table tab_no_index(id int,name varchar(10)) engine=innodb;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Query OK, 0 rows affected (0.15 sec)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into tab_no_index values(1,&#x27;1&#x27;),(2,&#x27;2&#x27;),(3,&#x27;3&#x27;),(4,&#x27;4&#x27;);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Records: 4 Duplicates: 0 Warnings: 0</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031609705.png"></p>
<p>在上面的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！<strong>原因就是在没有索引的情况下，InnoDB只能使用表锁。</strong>当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下例所示： <br>创建tab_with_index表，id字段有普通索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table tab_with_index(id int,name varchar(10)) engine=innodb;</span><br><span class="line">mysql&gt; alter table tab_with_index add index id(id);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031609475.png"></p>
<p>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。 <br>在下面的例子中，表tab_with_index的id字段有索引，name字段没有索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table tab_with_index drop index name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Query OK, 4 rows affected (0.22 sec) Records: 4 Duplicates: 0 <br>Warnings: 0</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into tab_with_index  values(1,&#x27;4&#x27;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Query OK, 1 row affected (0.00 sec)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tab_with_index where id = 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031609546.png"></p>
<p>InnoDB存储引擎使用相同索引键的阻塞例子 <br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031609643.png"></p>
<p>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。 <br>在下面的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table tab_with_index add index name(name);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Query OK, 5 rows affected (0.23 sec) Records: 5 Duplicates: 0 <br>Warnings: 0</p>
</blockquote>
<p><strong>InnoDB存储引擎的表使用不同索引的阻塞例子</strong> <br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031609643.png"></p>
<p>（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突 时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。 <br>比如，在tab_with_index表里的name字段有索引，但是name字段是varchar类型的，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到这一点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tab_with_index where name = 1 \G</span><br><span class="line">mysql&gt; explain select * from tab_with_index where name = &#x27;1&#x27; \G</span><br></pre></td></tr></table></figure>

<h2 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a>间隙锁（Next-Key锁）</h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。 <br>举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select * from  emp where empid &gt; 100 for update;</span><br></pre></td></tr></table></figure>

<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况，在后续的章节中会做进一步介绍。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待<strong>。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</strong></p>
<p>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！下面这个例子假设emp表中只有101条记录，其empid的值分别是1,2,……,100,101。 <br>InnoDB存储引擎的间隙锁阻塞例子 <br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031610658.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文重点介绍了MySQL中MyISAM表级锁和InnoDB行级锁的实现特点，并讨论了两种存储引擎经常遇到的锁问题和解决办法。</p>
<p><strong>对于MyISAM的表锁，主要讨论了以下几点：</strong> <br>（1）共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。 <br>（2）在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。 <br>（3）MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。 <br>（4）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p>
<p><strong>对于InnoDB表，本文主要讨论了以下几项内容：</strong> <br>（1）InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。 <br>（2）介绍了InnoDB间隙锁（Next-key)机制，以及InnoDB使用间隙锁的原因。 <br>在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p>
<p>在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p>
<ul>
<li>  尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</li>
<li>  选择合理的事务大小，小事务发生锁冲突的几率也更小；</li>
<li>  给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</li>
<li>  不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</li>
<li>  尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</li>
<li>  对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>
<blockquote>
<p>转自：<a href="https://www.cnblogs.com/leedaily/p/8378779.html">https://www.cnblogs.com/leedaily/p/8378779.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常见优化汇总</title>
    <url>/2016/02/03/MySQL%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h3><ol>
<li>客户端发送一条查询给服务器；</li>
<li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果；</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li>
<li>将结果返回给客户端。</li>
</ol>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><ol>
<li>是否向数据库请求了不必要的数据；</li>
<li>是否扫描了过多的数据，衡量查询开销三个指标：响应时间、扫描行数、返回行数；</li>
<li>没有索引或者没有用到索引；</li>
</ol>
<h3 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h3><ul>
<li>方法一：全局变量设置</li>
</ul>
<p>将 <code>slow_query_log</code> 全局变量设置为“ON”状态</p>
<blockquote>
<p>mysql&gt; set global slow_query_log=’ON’; </p>
</blockquote>
<p>设置慢查询日志存放的位置</p>
<blockquote>
<p>mysql&gt; set global slow_query_log_file=’/usr/local/mysql/data/slow.log’;</p>
</blockquote>
<p>查询超过1秒就记录</p>
<blockquote>
<p>mysql&gt; set global long_query_time=1;</p>
</blockquote>
<ul>
<li>方法二：配置文件设置</li>
</ul>
<p>修改配置文件 <code>my.cnf</code> ，在 <code>[mysqld]</code> 下的下方加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">slow_query_log = ON </span><br><span class="line">slow_query_log_file = /usr/local/mysql/data/slow.log </span><br><span class="line">long_query_time = 1</span><br></pre></td></tr></table></figure>
<p>重启MySQL服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<h3 id="查询优化神器explain"><a href="#查询优化神器explain" class="headerlink" title="查询优化神器explain"></a>查询优化神器explain</h3><p>语法：<code>EXPLAIN SELECT * from user_info WHERE id &lt; 300;</code></p>
<p>EXPLAIN 命令的输出内容大致如下:</p>
<blockquote>
<p>mysql&gt; explain select * from user_info where id = 2;<br> id: 1<br>select_type: SIMPLE<br>table: user_info<br>type: const<br>possible_keys: PRIMARY<br>key: PRIMARY<br>key_len: 8<br>ref: const<br>rows: 1 filtered: 100.00<br>Extra: NULL<br>1 row in set, 1 warning (0.00 sec)</p>
</blockquote>
<p>各列的含义如下:</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li><strong>type: 显示连接使用的类型</strong></li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引</li>
<li>key_len:使用的索引的长度</li>
<li><strong>ref:显示索引的哪一列被使用了</strong></li>
<li><strong>rows: 显示此查询一共扫描了多少行. 这个是一个估计值</strong></li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<p><code>type</code> 参数可以帮助我们判断此次查询是全表扫描还是索引扫描，它的值有以下几种：</p>
<ul>
<li>system</li>
</ul>
<p>表中只有一条数据，这个类型是特殊的 const 类型。</p>
<ul>
<li>const</li>
</ul>
<p>针对主键或唯一索引的等值查询扫描，最多只返回一行数据，const 查询速度非常快。</p>
<blockquote>
<p>实例：explain select * from user_info where id = 2</p>
</blockquote>
<ul>
<li>eq_ref</li>
</ul>
<p>此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是 =，查询效率较高。索引是UNIQUE或PRIMARY KEY。</p>
<blockquote>
<p>实例： explain select * from user_info, order_info where user_info.id = order_info.user_id</p>
</blockquote>
<ul>
<li>ref</li>
</ul>
<p>此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。</p>
<ul>
<li>range</li>
</ul>
<p>表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。</p>
<blockquote>
<p>实例： EXPLAIN SELECT  *  FROM user_info WHERE id BETWEEN 2 AND 8</p>
</blockquote>
<ul>
<li>index</li>
</ul>
<p>表示全索引扫描和ALL类型类似，只不过ALL类型是全表扫描，而index类型则仅仅扫描所有的索引而不扫描数据。</p>
<p>index类型通常出现在所要查询的数据直接在索引树中可以获取到而不需要扫描数据这种场景下，这个时候，Extra字段显示为Using index。</p>
<ul>
<li>all</li>
</ul>
<p>表示全表扫描，这个类型的查询是性能最差的查询之一，通常来说, 我们的查询不应该出现ALL类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能来说是巨大的灾难，如果一个查询是ALL类型查询，通常情况下可以对相应的字段添加索引来避免。</p>
<p><code>rows</code> 显示MYSQL执行查询的行数，简单且重要，数值越大越不好，说明没有用好索引。</p>
<h3 id="查询优化注意点"><a href="#查询优化注意点" class="headerlink" title="查询优化注意点"></a>查询优化注意点</h3><ol>
<li>不要使用 select * from table ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</li>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>当只要一行数据时使用LIMIT1。</li>
<li>尽量不用负向查询（!=、NOT IN…）。</li>
<li>尽量用in查询代替or条件。</li>
</ol>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h3><ol>
<li><p><strong>单列索引</strong><br>由关键字KEY或INDEX定义的索引，其唯一任务是加快对数据的访问速度， 它的sql格式是<br><code>CREATE INDEX IndexName ON TableName(字段名(length))</code><br>或者<br><code>ALTER TABLE TableName ADD INDEX IndexName(字段名(length))</code></p>
</li>
<li><p><strong>唯一索引</strong><br>与普通索引类似，不同的是唯一索引要求所有的列的值是唯一的，这一点和主键索引一样，区别是它允许有空值，其sql格式是<br><code>CREATE UNIQUE INDEX IndexName ON TableName(字段名(length))</code><br>或者 <br><code>ALTER TABLE TableName ADD UNIQUE (columnList) </code></p>
</li>
<li><p><strong>组合索引</strong><br>一个表中含有多个单列索引不代表是组合索引，通俗一点讲，组合索引是:<strong>包含多个字段但是只有一个索引名称</strong>，其sql格式是<br><code>CREATE INDEX IndexName On TableName(字段名(length), 字段名(length),...)</code>，如果建立了组合索引<code>(nickname,account,createTime)</code> ，那么他实际包含的是3个索引:<br><code>(nickname)</code>、<code>(nickname,account)</code>、<code>(nickname,account,createTime)</code>。</p>
</li>
</ol>
<h3 id="索引使用需要注意的点"><a href="#索引使用需要注意的点" class="headerlink" title="索引使用需要注意的点"></a>索引使用需要注意的点</h3><ol>
<li><p><strong>负向条件查询不能使用索引</strong><br><code>select * from order where status!=0 and stauts!=1</code><br><code>not in/not exists</code> 都不是好习惯，可以优化为in查询：<br><code>select * from order where status in(2,3)</code></p>
</li>
<li><p><strong>前导模糊查询无法使用索引</strong><br><code>select * from order where desc like &#39;%XX&#39;</code> 无法使用索引<br><code>select * from order where desc like &#39;XX%&#39;</code> 使用到了索引
 </p>
</li>
<li><p><strong>在属性上进行计算不能命中索引</strong><br><code>select * from order where YEAR(date) &lt; = &#39;2017&#39;</code><br>即使date上建立了索引，也会全表扫描，可优化为值计算：<br><code>select * from order where date &lt; = CURDATE()</code><br>或者：<br><code>select * from order where date &lt; = &#39;2017-01-01&#39;</code></p>
</li>
<li><p><strong>复合索引最左前缀，并不是指SQL语句的where顺序要和复合索引一致</strong><br>用户表中建立了(login_name, passwd)的复合索引<br><code>select * from user where login_name=? and passwd=?</code><br><code>select * from user where passwd=? and login_name=?</code><br>都能够命中索引<br><code>select * from user where login_name=?</code><br>也能命中索引，满足复合索引最左前缀<br><code>select * from user where passwd=?</code><br>不能命中索引，不满足复合索引最左前缀</p>
</li>
<li><p><strong>数据区分度不大的字段不宜使用索引</strong><br><code>select * from user where sex=1</code><br>原因：SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引。</p>
</li>
<li><p><strong>强制类型转换会全表扫描</strong><br><code>select * from user where telphone=13416348194</code><br>如果telphone为varchar类型，数据库会进行强制类型转换而导致索引失效。</p>
</li>
</ol>
<h2 id="表结构优化"><a href="#表结构优化" class="headerlink" title="表结构优化"></a>表结构优化</h2><h3 id="表的设计规范"><a href="#表的设计规范" class="headerlink" title="表的设计规范"></a>表的设计规范</h3><ol>
<li><strong>永远为每张表设置一个主键</strong>      </li>
</ol>
<ul>
<li>主键递增，数据行写入可以提高插入性能</li>
<li>主键要选择较短的数据类型，因为较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li>
</ul>
<ol start="2">
<li><strong>尽可能的使用 <code>NOT NULL</code></strong>     </li>
</ol>
<ul>
<li><code>null</code> 的列使索引更加复杂，对MySQL来说更难优化</li>
<li><code>null</code> 值需要更多的存储空间，无论是表还是索引中每行中的null的列都需要额外的空间来标识</li>
<li>对 <code>null</code> 做处理的时候，只能采用 <code>is null</code> 或 <code>is not null</code>，而不能采用<code>=</code>、<code>in</code>、<code>&lt;</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>not in</code>这些操作符号</li>
</ul>
<ol start="3">
<li><p><strong>必须使用InnoDB存储引擎</strong><br>支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p>
</li>
<li><p><strong>必须使用UTF8字符集</strong><br>无需转码，无乱码风险，节省空间</p>
</li>
<li><p><strong>字段类型尽量使用最小、最简单的数据类型</strong><br>如用 <code>TINYINT</code> 代替 <code>INT</code>，<code>VARCHAR</code> 的长度只分配真正需要的空间<br>占用更少的磁盘、内容、CPU缓存，大大减少IO开销</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《小狗钱钱》书中的精华都在这了</title>
    <url>/2020/09/24/%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031629594.png"></p>
<h3 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h3><p>初次看《小狗钱钱》，竟有一种莫名的感动，在我看来，书中的小狗钱钱，就像来自未来的次世代机器人，通晓世间的一切，而它愿意把关于金钱的一切都告诉主人公，我就这样跟随着主人公的脚步，贪婪的吸收着他们之间交流的一切，生怕错过了这一窥探金钱真谛的机会。</p>
<span id="more"></span>
<p>可以说，这本书就是《富爸爸穷爸爸》的童话版，虽然讲的道理大同小异，但是作者用更通俗易懂、更具实操性的叙述方式，将自身实现财务自由所用到的武功招式及内功心法一一展示给读者，使读者读来神清气爽，一气呵成，易于接受，是学习理财不可多得的入门书籍。</p>
<p>那么，在金钱这件事上，小狗钱钱都告诉了我们哪些东西来帮助我们变得富有呢，我在这里总结一下其中具有实操性的内容，也算是自我学习。</p>
<h3 id="愿望清单"><a href="#愿望清单" class="headerlink" title="愿望清单"></a>愿望清单</h3><p>列出自己想要变得富有的愿望清单，说的直白点就是，我为什么要变得富有，我对金钱到底有多渴望，越具体越好，就像这样：</p>
<ul>
<li><em>去某个城市旅行</em></li>
<li><em>拥有一辆代步车</em></li>
<li><em>拥有一套大房子</em></li>
<li>…</li>
</ul>
<blockquote>
<p>思考：这个做法就是挖掘自己想要变得富有的具体原因，清楚自己想要的是什么</p>
</blockquote>
<h3 id="制作梦想相册"><a href="#制作梦想相册" class="headerlink" title="制作梦想相册"></a>制作梦想相册</h3><p>选出最想要实现的愿望，将其有关的照片制作成梦想相册，每天看几遍，并想象愿望已经实现后的情景，体会那种快感。</p>
<p>把想象的东西视觉化，你的愿望就更容易实现，这其中的道理不需要深究，就好像<strong>按了开关灯就会立即点亮</strong>一样简单，你只需要做这件事就好了。</p>
<h3 id="梦想储蓄罐"><a href="#梦想储蓄罐" class="headerlink" title="梦想储蓄罐"></a>梦想储蓄罐</h3><p>为相对较容易实现的愿望准备梦想储蓄罐并坚持定期向每个梦想储蓄罐存钱，直至实现。如：旅行、代步车这些相对较小的愿望可以准备梦想储蓄罐。</p>
<p>只有不断地向梦想储蓄罐存钱，你才会紧盯目标，并以目标为激励，寻找一切可实现目标的机会，一步步实现每一个愿望。就像书中的主人公一样，为了能去国外学习，他拼命的想尽一切办法赚钱，这种愿望是具体而强烈的。</p>
<blockquote>
<p>思考：</p>
<p>梦想相册和梦想储蓄罐两个方法是为了持续性的强化自己的愿望，人性是懒惰的，即使心中有愿望，如果不足够强烈，很容易就淹没在生活的琐事中，然而作者已经为我们指出了行之有效的方法，我们只需拿来照做即可，它是否起作用不必深究，作者已经用自己的实际行动帮我们验证过，相信即可，就如同按下开关灯就会亮那样简单。</p>
<p>梦想储蓄罐还有一个非常重要的作用：专款专用，避免透支消费。</p>
</blockquote>
<h3 id="成功日记"><a href="#成功日记" class="headerlink" title="成功日记"></a>成功日记</h3><p>想要达成目标并不是一件容易的事情，我们常常会因为信心不足而中途放弃，而树立自信最简单的方式就是把自己已经做成功的事情写下来，任何小事都行，每天都写，你会发现，越写越有自信。而想要积累更多的成功的事情，有一个原则就是：<strong>做你自己擅长的事情，把精力集中在你知道的、能做的和拥有的东西上。</strong>因为，很多时候，我们会花很多时间去想我们不知道、不能做或没有的东西上面。</p>
<h3 id="遵循72小时原则"><a href="#遵循72小时原则" class="headerlink" title="遵循72小时原则"></a>遵循72小时原则</h3><p>如果决定去做一件事，必须在72小时之内开始，否则很可能永远不会开始。</p>
<p>比如以上提到的这些方法，如果你认同并且最终想要变得富有的话，你必须马上开始去做，并且不能抱着「试试看」的心态，必须切实认真的去执行，否则就等于还没有做就已经给自己想好了退路，没错，不能实验，<strong>只有两个选择——做或者不做</strong>。</p>
<h3 id="养一只”鹅”给你下蛋"><a href="#养一只”鹅”给你下蛋" class="headerlink" title="养一只”鹅”给你下蛋"></a>养一只”鹅”给你下蛋</h3><p>学会用钱生钱，才是走向财务自由的终极之道。书中所讲的”鹅”就是用来生钱的钱，而”利息”就是金蛋，而要养一只”鹅”，就要为它不断的投入金钱，让”鹅”越来越肥，下的蛋越来越大。因此，在梦想储蓄罐之外，再设立一个养鹅账户变得很有必要。</p>
<p>到这里，作者把我们赚到的钱分成了梦想储蓄罐、养鹅账户以及日常开销三个部分，这个资金分配方式和”标准普尔家庭资产象限图”描述的方法有着异曲同工之妙，这也从侧面印证了资金的合理规划对于理财的重要性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不难发现，作者实际上是按照 <strong>确定目标——强化目标——实现目标</strong> 的思路，为我们量身定制了实操性极强的方法来帮助我们建立富人的思维及行为模式，道理很简单，难点就在于持续坚持，如果我们能把这些方法贯彻始终，即使最终不能实现财务自由，至少也不会出现太严重的财务问题。而在现实生活中，我看到很多朋友因为信用卡透支严重，每个月都要借钱填补窟窿，这就是对金钱没有任何规划造成的。</p>
<p>有人说要先有钱才能理财，实际上理财首先需要提升的是正确规划资金的认知，而不是如何变得有钱，只有认知改变了，才能以正确的方式对待金钱，最终才能朝着财务自由的方向行走。</p>
<p>财务自由这个愿望足够大，它更多的是对金钱的观念上的改变，具体的说，就是对金钱的合理规划的一系列方法，当我们开始使用这些方法去分配我们的金钱，我们实际上就已经开始用富人的思维思考，梦想储蓄罐这一系列做法，就是我们初尝这些方法的第一步。</p>
<p>当然，以上只是书中的一部分内容，也是我认为比较重要又容易被忽视的东西，因为它足够简单，但是大道至简，需持之以恒，才能体现出它的作用，感兴趣的朋友一定要去看一看。</p>
]]></content>
      <categories>
        <category>开卷有益</category>
      </categories>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title>更换电脑后，如何继续使用hexo更新博客？</title>
    <url>/2017/11/15/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8hexo%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>最近在使用hexo更新博客的过程中，发现一个比较麻烦的事情，就是修改配置文件后，不能便捷的把配置同步到其它电脑上，直接拷贝配置文件到其它电脑显然不是一个明智的选择，总有出错的时候，并且没法追溯历史修改，于是，用git的分支来管理hexo的源码和静态文件便是不二的选择，简单总结一下。</p>
<span id="more"></span>


<h3 id="初始搭建流程"><a href="#初始搭建流程" class="headerlink" title="初始搭建流程"></a>初始搭建流程</h3><ul>
<li>创建仓库之后创建master（放静态文件）和hexo（放源码）两个分支；</li>
<li>使用<code>git clone -b hexo 仓库地址</code> 命令拷贝 <code>hexo</code> 分支到本地；</li>
<li>进入本地仓库文件夹，保持在hexo分支，依次执行<code>npm install hexo</code>、<code>hexo init</code>、<code>npm install</code> 和 <code>npm install hexo-deployer-git</code>；</li>
<li>根据需要修改hexo配置文件，注意deplay参数的分支应该为master；</li>
<li>依次执行<code>git add .</code> 、<code>git commit -m &quot;...&quot;</code> 、<code>git push origin hexo</code> 把源码提交到远程hexo分支；</li>
<li>接着执行 <code>hexo d -g</code> 部署网站到GitHub Pages。</li>
</ul>
<p>这样就是一个完整的流程了，你会发现，hexo自动生成的文件里面已经有一个<code>.gitignore</code>文件，说明其本意就是希望我们把源码存放到github，这个文件里面已经帮我们设置好了哪些文件不应该被提交，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： <code>themes</code> 文件夹因为一次修改好之后几乎不会有什么变动了，可以跟随源码一起存放到gitgub，这样换电脑的时候就不用再配置主题，如果需要换新的主题，提交源码的时候把新的主题包加进去即可。</p>
</blockquote>
<h3 id="日常更新流程"><a href="#日常更新流程" class="headerlink" title="日常更新流程"></a>日常更新流程</h3><p>本地更新博客（文章及样式修改）后，按照下面两步走来进行代码更新。</p>
<ul>
<li>依次执行 <code>git add .</code>、<code>git commit -m &quot;...&quot;</code>、<code>git push origin hexo</code>更新源码到远程hexo分支；</li>
<li>执行 <code>hexo d -g</code> 部署网站到GitHub Pages。</li>
</ul>
<blockquote>
<p>注：建议严格按照以上两个步骤来执行，如果先执行第2步，在极端情况下（比如突然停电、死机），会导致源码部分丢失。</p>
</blockquote>
<h3 id="更换电脑后的流程"><a href="#更换电脑后的流程" class="headerlink" title="更换电脑后的流程"></a>更换电脑后的流程</h3><p>换电脑后，按照以下步骤操作：</p>
<ul>
<li>使用<code>git clone -b hexo 仓库地址 </code> 命令拷贝 <code>hexo</code> 分支到本地；</li>
<li>进入本地仓库文件夹，保持在hexo分支，依次执行<code>npm install hexo</code>、<code>npm install</code>；</li>
</ul>
<blockquote>
<p>注：这里不需要 <code>hexo init</code> 命令了，另外，平时安装插件的时候记得加上 <code>--save</code> 参数，这样 <code>package.json</code>文件里就会写入插件的安装信息，当我们换电脑的时候，只需要 <code>npm install</code> 命令即可安装所有插件。</p>
</blockquote>
<p>最后说一下，因为github pages要求代码库不能是私有的，如果你觉得用这种方式保存源码不够安全的话，可以重新创建一个私有库专门保存源码，使用流程上也不会有太大的变化。</p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用acme.sh申请免费的HTTPS证书</title>
    <url>/2020/08/15/%E4%BD%BF%E7%94%A8acme-sh%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E7%9A%84HTTPS%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>最近把自己的网站从HTTP升级为HTTPS，在这里把过程及踩过的坑记录一下。</p>
<p><a href="https://github.com/Neilpang/acme.sh"><code>acme.sh</code></a>是一个纯粹用Shell语言编写的脚本，本质上是一个实现了ACME协议的客户端，它足够简单，功能强大且易于使用，可以实现自动颁发、续订和安装证书，目前支持ZeroSSL、BuyPass、Let`s Encrypt等多种不同证书，本文使用的是ZeroSSL证书。</p>
<span id="more"></span>

<h3 id="安装acme-sh"><a href="#安装acme-sh" class="headerlink" title="安装acme.sh"></a>安装acme.sh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://get.acme.sh | sh</span><br></pre></td></tr></table></figure>
<p>该安装脚本做了几件事：</p>
<ul>
<li>把 acme.sh 安装到了 home 目录下：~/.acme.sh/</li>
<li>创建了一个 bash 的 alias, 方便使用: alias acme.sh=~/.acme.sh/acme.sh</li>
<li>创建了cronjob，每天 0:00点自动检测所有的证书，如果快过期了，则会自动更新证书。</li>
</ul>
<p>可能会因为网络问题无法自动安装，则需要手动更改安装脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载并保存脚本</span><br><span class="line">curl https://get.acme.sh -o acme_install.sh</span><br><span class="line"></span><br><span class="line"># 更改脚本内域名，使用代理加速</span><br><span class="line">sed -i &#x27;s/raw/ghproxy.com\/https:\/\/raw/g&#x27; acme_install.sh</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">chmod +x acme_install.sh</span><br><span class="line">./acme_install.sh</span><br></pre></td></tr></table></figure>
<p>或者直接手动安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/acmesh-official/acme.sh.git</span><br><span class="line">cd ./acme.sh</span><br><span class="line">./acme.sh --install</span><br></pre></td></tr></table></figure>

<h3 id="注册-ZeroSSL-账号"><a href="#注册-ZeroSSL-账号" class="headerlink" title="注册 ZeroSSL 账号"></a>注册 ZeroSSL 账号</h3><p>申请证书之前建议先去ZeroSSL官网注册账号，ZeroSSL官网地址：<a href="https://zerossl.com/">https://zerossl.com</a></p>
<p>也可以直接使用以下命令来注册，如果已经在官网注册，该命令会自动关联账户，邮箱改为你自己的ZeroSSL邮箱，一定不要随便填。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --register-account  -m myemail@example.com --server zerossl</span><br></pre></td></tr></table></figure>


<h3 id="将-acme-sh-的注册服务器改为-ZeroSSL"><a href="#将-acme-sh-的注册服务器改为-ZeroSSL" class="headerlink" title="将 acme.sh 的注册服务器改为 ZeroSSL"></a>将 acme.sh 的注册服务器改为 ZeroSSL</h3><p>如果你的<code>acme.sh</code> 是2.x版本，默认使用Let`s Encrypt作为服务提供商，我们可以通过以下命令，将其更换为ZeroSSL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --set-default-ca --server zerossl</span><br></pre></td></tr></table></figure>

<h3 id="配置DNS-API"><a href="#配置DNS-API" class="headerlink" title="配置DNS API"></a>配置DNS API</h3><p>本文使用 DNS 验证的方法来验证域名，<code>acme.sh</code> 可以通过 DNS 提供商的 API 自动设置验证记录，具体用法详见文档：<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">https://github.com/acmesh-official/acme.sh/wiki/dnsapi</a><br>常用的 CloudFlare 、 DNSPod 、 CloudXNS 、阿里云 等DNS服务都支持。</p>
<p>以阿里云为例，登录后台找到账号的秘钥(建议创建子账号来专门管理此功能)：<br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031634278.png"><br>如果你使用的是子账号，一定要给子账号开通以下权限：<br><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112031634007.png"><br>接下来执行下面命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export Ali_Key=&quot;****************************&quot;</span><br><span class="line">export Ali_Secret=&quot;**************************&quot; </span><br></pre></td></tr></table></figure>

<h3 id="签发证书"><a href="#签发证书" class="headerlink" title="签发证书"></a>签发证书</h3><p>以zmtupian.com为例，该域名使用阿里云解析，在上面的步骤中已经配置好阿里云DNS API</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --dns dns_ali --issue -d zmtupian.com -d *.zmtupian.com</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><p>–dns 指定 DNS 服务商，dns_ali 代表阿里云，还有 dns_cf 代表 CloudFlare，更多的字段见 <a href="https://github.com/acmesh-official/acme.sh/tree/master/dnsapi">https://github.com/acmesh-official/acme.sh/tree/master/dnsapi</a></p>
<p>如果不使用 API 自动添加验证，则不用添加后续参数，如：acme.sh –issue –dns -d example.com ….</p>
</li>
<li><p>-d *.example.com 表示签发泛域名证书</p>
</li>
</ul>
<p>执行命令之后看输出的内容可以确定证书所在位置，这时就签发成功了。</p>
<h3 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --install-cert -d zmtupian.com \</span><br><span class="line">        --key-file       /var/www/ssl/zmtupian.com.key  \</span><br><span class="line">        --fullchain-file /var/www/ssl/zmtupian.com.cert \</span><br><span class="line">        --reloadcmd     &quot;service nginx force-reload&quot;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>–key-file 和 -fullchain-file 后接想要安装到的目录及证书名</li>
<li>–reloadcmd 后接服务的重启命令，程序自动续期证书后会运行该命令使其生效，一定不能漏</li>
</ul>
<p>默认情况下，证书将每60天更新一次（可配置），证书更新后，服务将通过reloadcmd设置的命令自动重新加载。</p>
<h3 id="启用https服务"><a href="#启用https服务" class="headerlink" title="启用https服务"></a>启用https服务</h3><p>修改服务器的配置文件启用HTTPS，以nginx为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name  www.zmtupian.com zmtupian.com;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /var/www/ssl/zmtupian.com.cert;</span><br><span class="line">        ssl_certificate_key  /var/www/ssl/zmtupian.com.key;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.zmtupian.com zmtupian.com;</span><br><span class="line"></span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置好后，检查是否有错误，然后重启服务器即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">service nginx force-reload</span><br></pre></td></tr></table></figure>

<p>最后，记得去服务器管理后台打开服务器443端口。</p>
<p>大功告成！</p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>CHROME开发者工具的小技巧</title>
    <url>/2017/06/30/CHROME%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>Chrome的开发者工具是个很强大的东西，相信程序员们都不会陌生，不过有些小功能可能并不为大众所知，所以，写下这篇文章罗列一下可能你所不知道的功能，有的功能可能会比较实用，有的则不一定，也欢迎大家补充交流。<br>话不多话，我们开始。</p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>有很多css/js的代码都会被 minify 掉，你可以点击代码窗口左下角的那个 { }  标签，chrome会帮你给格式化掉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301532863.gif"></p>
<h2 id="强制DOM状态"><a href="#强制DOM状态" class="headerlink" title="强制DOM状态"></a>强制DOM状态</h2><p>有些HTML的DOM是有状态的，比如 <code>&lt;a&gt;</code> 标签，其会有 <code>active</code>，<code>hover</code>， <code>focus</code>，<code>visited</code> 这些状态，有时候，我们的CSS会来定义不同状态的样式，在分析网页查看网页上DOM的CSS样式时，我们可以点击CSS样式上的 :hov 这个小按钮来强制这个DOM的状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301533369.gif"></p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>现在的网页上都会有一些动画效果。在Chrome的开发者工具中，通过右上角的菜单中的 More Tools =&gt; Animations 呼出相关的选项卡。于是你就可以慢动作播放动画了（可以点选 25% 或 10%），然后，Chrome还可以帮你把动画录下来，你可以拉动动再画的过程，甚至可以做一些简单的修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301535857.gif"> </p>
<h2 id="直接编辑网页"><a href="#直接编辑网页" class="headerlink" title="直接编辑网页"></a>直接编辑网页</h2><p>在你的 console 里 输入下面的命令：<br><code>document.designMode = &quot;on&quot;</code><br>于是你就可以直接修改网页上的内容了。</p>
<p>P.S. 下面这个抓屏中还演示了一个如何清空console的示例。你可以输入 <code>clear()</code> 或是 按 <code>Ctrl+L</code>（Windows下），<code>CMD + K</code> (Mac下)</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301540545.gif"></p>
<h2 id="网络限速"><a href="#网络限速" class="headerlink" title="网络限速"></a>网络限速</h2><p>你可以设置你的网络的访问速度来模拟一个网络很慢的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301541527.gif"></p>
<h2 id="复制HTTP请求"><a href="#复制HTTP请求" class="headerlink" title="复制HTTP请求"></a>复制HTTP请求</h2><p>这个是我很喜欢 的一个功能，你可以在network选项卡里，点击 XHR 过滤相关的Ajax请求，然后在相关的请求上点鼠标右键，在菜单中选择： <code>Copy =&gt; Copy as cURL</code> ，然后就可以到你的命令行下去 执行 curl 的命令了。这个可以很容易做一些自动化的测试。</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301542425.gif"></p>
<blockquote>
<p>友情提示：这个操作有可能会把你的个人隐私信息复制出去，比如你个人登录后的cookie。</p>
</blockquote>
<h2 id="抓个带手机的图"><a href="#抓个带手机的图" class="headerlink" title="抓个带手机的图"></a>抓个带手机的图</h2><p>这个可能有点无聊了，不过我觉得挺有意思的。<br>在device显示中，先选择一个手机，然后在右上角选 Show Device Frame，然后你就看到手机的样子了，然后再到那个菜中中选 Capture snapshot，就可以抓下一个有手机样子的截图了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301543097.gif"></p>
<p>我抓的图如下（当然，不是所有的手机都有frame的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301544752.png"></p>
<h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>除了给Javascript的源代码上设置断点调试，你还可以：</p>
<h3 id="给DOM设置断点"><a href="#给DOM设置断点" class="headerlink" title="给DOM设置断点"></a>给DOM设置断点</h3><p>选中一个DOM，然后在右键菜单中选 Break on … 你可以看到如下三个选项：</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301545952.png"></p>
<h3 id="给XHR和Event-Lisener设置断点"><a href="#给XHR和Event-Lisener设置断点" class="headerlink" title="给XHR和Event Lisener设置断点"></a>给XHR和Event Lisener设置断点</h3><p>在 Sources 面页中，你可以看到右边的那堆break points中，除了上面我们说的给DOM设置断点，你还可以给XHR和Event Listener设置断点，载图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301546434.png"></p>
<h2 id="关于Console中的技巧"><a href="#关于Console中的技巧" class="headerlink" title="关于Console中的技巧"></a>关于Console中的技巧</h2><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>chrome会帮你buffer 5个你查看过的DOM对象，你可以直接在Console中用 $0, $1, $2, $3, $4来访问。<br>你还可以使用像jQuery那样的语法来获得DOM对象，如：<code>$(&quot;#mydiv&quot;)</code><br>你还可使用 <code>$$(&quot;.class&quot;)</code> 来选择所有满足条件的DOM对象。<br>你可以使用 <code>getEventListeners($(&quot;selector&quot;))</code> 来查看某个DOM对象上的事件（如下图所示）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301546294.png"></p>
<p>你还可以使用 <code>monitorEvents($(&quot;selector&quot;))</code> 来监控相关的事件。比如：<br><code>monitorEvents(document.body, &quot;click&quot;)</code>;</p>
<h3 id="Console中的一些函数"><a href="#Console中的一些函数" class="headerlink" title="Console中的一些函数"></a>Console中的一些函数</h3><ul>
<li><p>monitor函数<br>使用 monitor函数来监控一函数，如下面的示例</p>
</li>
<li><p>copy函数<br>copy函数可以把一个变量的值copy到剪贴板上。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301551583.png"></p>
<ul>
<li>inspect函数<br>inspect函数可以让你控制台跳到你需要查看的对象上。如：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301551022.png"></p>
<blockquote>
<p>更多的函数请参数官方文档 –  <a href="https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference">Using the Console / Command Line Reference</a></p>
</blockquote>
<h3 id="Console的输出"><a href="#Console的输出" class="headerlink" title="Console的输出"></a>Console的输出</h3><p>我们知道，除了 <code>console.log</code> 之外，还有 <code>console.debug</code> ，<code>console.info</code> ，<code>console.warn</code> ，<code>console.error</code> 这些不同级别的输出。另外一个鲜为人知的功能是，<code>console.log</code> 中，你还可以对输出的文本加上css的样式，如下所示：<br><code>console.log(&quot;%c左耳朵&quot;, &quot;font-size:90px;color:#888&quot;)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301613100.png"></p>
<p>于是，你可以定义一些相关的log函数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.todo = function(msg)&#123;  </span><br><span class="line">    console.log( &#x27;%c%s %s %s&#x27;, &#x27;font-size:20px; color:yellow; background-color: blue;&#x27;, &#x27;--&#x27;, msg, &#x27;--&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.important = function(msg)&#123;  </span><br><span class="line">    console.log( &#x27;%c%s %s %s&#x27;, &#x27;font-size:20px; color:brown; font-weight: bold; text-decoration: underline;&#x27;, &#x27;--&#x27;, msg, &#x27;--&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301614909.png"></p>
<p>关于console.log中的格式化，你可以参看如下表格：</p>
<table>
<thead>
<tr>
<th>指示符</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>格式化输出一个字符串变量。</td>
</tr>
<tr>
<td>%i</td>
<td>or %d 格式化输出一个整型变量的值。</td>
</tr>
<tr>
<td>%f</td>
<td>格式化输出一个浮点数变量的值。</td>
</tr>
<tr>
<td>%o</td>
<td>格式化输出一个DOM对象。</td>
</tr>
<tr>
<td>%O</td>
<td>格式化输出一个Javascript对象。</td>
</tr>
<tr>
<td>%c</td>
<td>为后面的字符串加上CSS样式</td>
</tr>
</tbody></table>
<p>除了console.log打印js的数组，你还可以使用console.table来打印，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var pets = [  </span><br><span class="line">    &#123; animal: &#x27;Horse&#x27;, name: &#x27;Pony&#x27;, age: 23 &#125;,  </span><br><span class="line">    &#123; animal: &#x27;Dog&#x27;, name: &#x27;Snoopy&#x27;, age: 13 &#125;,  </span><br><span class="line">    &#123; animal: &#x27;Cat&#x27;, name: &#x27;Tom&#x27;, age: 18 &#125;,  </span><br><span class="line">    &#123; animal: &#x27;Mouse&#x27;, name: &#x27;Jerry&#x27;, age: 12&#125;</span><br><span class="line">];</span><br><span class="line">console.table(pets)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301625771.png"></p>
<h3 id="关于console对象"><a href="#关于console对象" class="headerlink" title="关于console对象"></a>关于console对象</h3><ul>
<li>console对象除了上面的打日志的功能，其还有很多功能，比如：</li>
<li>console.trace() 可以打出js的函数调用栈</li>
<li>console.time() 和 console.timeEnd() 可以帮你计算一段代码间消耗的时间。</li>
<li>console.profile() 和 console.profileEnd() 可以让你查看CPU的消耗。</li>
<li>console.count() 可以让你看到相同的日志当前被打印的次数。</li>
<li>console.assert(expression, object) 可以让你assert一个表达式</li>
</ul>
<p>这些东西都可以看看<a href="https://developers.google.com/web/tools/chrome-devtools/console/console-reference">Google的Console API的文档</a>。<br>其实，还有很多东西，你可以参看Google的官方文档 – <a href="https://developers.google.com/web/tools/chrome-devtools/">Chrome DevTools</a></p>
<h3 id="关于快捷键"><a href="#关于快捷键" class="headerlink" title="关于快捷键"></a>关于快捷键</h3><p>点击在 DevTools的右上角的那三个坚排的小点，你会看到一个菜单，点选 <code>Shortcuts</code> ，你就可以看到所有的快捷键了</p>
<p><img src="https://cdn.jsdelivr.net/gh/huanshen1104/blog-imgs/202112301627476.png"></p>
<p>完。</p>
<blockquote>
<p>转自 酷 壳 – CoolShell<br>地址：<a href="https://coolshell.cn/articles/17634.html">https://coolshell.cn/articles/17634.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程艺术</category>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
</search>
